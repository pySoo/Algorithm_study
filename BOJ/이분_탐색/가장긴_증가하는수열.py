# https://www.acmicpc.net/problem/12015
"""
문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.
둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
"""
# DP에서 봤던 문제지만, N이 백만개이기 때문에 O(N^2)의 이중 for문으로 풀 수 없는 문제이다.
# 이 문제를 어떻게 이분 탐색으로 푸는지 감이 안 왔으나, 자리 비교를 통해 원소를 교체해서 풀 수 있었다.
# 예를 들어, [10,20,10]이라는 배열이 있을 때, 크기대로 배열한다면 [10,20]과 [10,10,20]은 증가하는 길이가 2로 똑같다.
# 따라서 이진 탐색으로 들어갈 자리를 탐색한다. [10,20]의 마지막 원소와 삽입하려는 원소 10을 비교해서 20보다 크지 않다면 [10,10]으로 자리를 교체하는 방식이다.
import sys
input = sys.stdin.readline
n = int(input())
arr = list(map(int, input().split()))
dp = [0]

# 이분 탐색: 원소가 들어갈 자리 찾기
for num in arr:
    # dp 마지막 원소보다 크다면 새로 삽입
    if dp[-1] < num:
        dp.append(num)

    # 그렇지 않다면 자리 교체
    else:
        start, end = 0, len(dp)
        while start <= end:
            mid = (start + end) // 2
            if arr[mid] < num:
                start = mid + 1
            else:
                end = mid - 1
        dp[end] = num
print(len(dp) - 1)
